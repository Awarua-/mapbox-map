<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../mapbox-import/maxpbox-import.html">

 <!-- <link rel="stylesheet" href="../../bower_components/mapbox.js/mapbox.css"> -->
  <!-- <link rel="import" type="css" href="../../bower_components/mapbox.js/mapbox.css"> -->
<dom-module id="map-box">
  
  <style>
      :host{
        position:relative;
      }
      :host #mapBox{
        bottom: 0;
        left: 0;
        position: absolute!important;
        right: 0;
        top: 0;
      }
  </style>

  <link rel="stylesheet" href="../../bower_components/mapbox.js/mapbox.css">
  <link rel="import" type="css" href="../../bower_components/mapbox.js/mapbox.css">
  <template>
    <div id="mapBox"></div>
    <content id="layers" select="*"></content>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'map-box',

    // Attributes
    properties: {

      accessToken: {
        type: String,
        value: 'pk.eyJ1IjoiZ251cnViIiwiYSI6InRZRVNjWDQifQ.'+
                  'Db2dDEClQ3ybQe_egT87lg',
        notify: true
      },

      latitude: {
        type: Number,
        value: 38.867847507701114,
        notify: true,
        reflectToAttribute: true,
        observer: '_updateCenter'
      },

      longitude: {
       type: Number,
       value: 38.867847507701114,
       notify: true,
       reflectToAttribute: true,
       observer: '_updateCenter'
      },

      zoom: {
        type: Number,
        value: 10,
        reflectToAttribute: true,
        notify: true,
        observer: '_updateCenter'
      },

      minZoom: {
        type: Number,
        value: 1,
        readOnly: true
      },

      maxZoom: {
        type: Number,
        value: 16,
        readOnly: true
      },

      /**
       * The `dragging` attribute sets whether  when he tries to pan outside the view.
       * 
       * @attribute dragging
       * @type bool
       */
      dragging: {
           type: Boolean,
           value: true
      },

      /**
       * The `touch-zoom` attribute sets whether the map can be zoomed by touch-dragging with two fingers. 
       * 
       * @attribute touch-zoom
       * @type bool
       */
      touchZoom: {
           type: Boolean,
           value: true
      },

      /**
       * The `scrollWheelZoom` attribute sets the whether the map can be zoomed by using the mouse wheel. If passed 'center', it will zoom to the center of the view regardless of where the mouse was.
       * 
       * @attribute scroll-wheel-zoom
       * @type bool
       */
      scrollWheelZoom: {
           type: Boolean,
           value: true
      },

      /**
       * The `double-click-zoom` attribute sets the whether the map can be zoomed in by double clicking on it and zoomed out by double clicking while holding shift. If passed 'center', double-click zoom will zoom to the center of the view regardless of where the mouse was.
       * 
       * @attribute double-click-zoom
       * @type bool
       */
      doubleClickZoom: {
           type: Boolean,
           value: true
      },

            /**
       * The `tap` attribute enables mobile hacks for supporting instant taps (fixing 200ms click delay on iOS/Android) and touch holds (fired as contextmenu events).
       * 
       * @attribute tap
       * @type bool
       */
      tap: {
           type: Boolean,
           value: true
      },
  
      /**
       * The `tap-tolerance` attribute sets the max number of pixels a user can shift his finger during touch for it to be considered a valid tap. 
       * 
       * @attribute tap-tolerance
       * @type number
       */
      tapTolerance: {
           type: Number,
           value: 15
      },
  
      /**
       * The `track-resize` attribute sets whether the map automatically handles browser window resize to update itself.
       * 
       * @attribute track-resize
       * @type bool
       */
      trackResize: {
           type: Boolean,
           value: true
      },
  
      /**
       * The `world-copy-jump` attribute sets whether the map tracks when you pan to another "copy" of the world and seamlessly jumps to the original one so that all overlays like markers and vector layers are still visible.
       * 
       * @attribute world-copy-jump
       * @type bool
       */
      worldCopyJump: {
           type: Boolean,
           value: false
      },
  
      /**
       * The `close-popup-on-click` attribute sets whether popups are closed when user clicks the map.
       * 
       * @attribute close-popup-on-click
       * @type bool
       */
      closePopupOnClick: {
           type: Boolean,
           value: true
      },
  
      /**
       * The `bounce-at-zoom-limits` attribute sets whether the map to zoom beyond min/max zoom and then bounce back when pinch-zooming.
       * 
       * @attribute bounce-at-zoom-limits
       * @type bool
       */
      bounceAtZoomLimits: {
           type: Boolean,
           value: true
      },
  
      /**
       * The `keyboard` attribute sets whether the map is focusable and allows users to navigate the map with keyboard arrows and +/- keys.
       * 
       * @attribute keyboard
       * @type bool
       */
      keyboard: {
           type: Boolean,
           value: true
      },
  
      /**
       * The `keyboard-pan-offset` attribute sets the amount of pixels to pan when pressing an arrow key.
       * 
       * @attribute keyboard-pan-offset
       * @type number
       */
      keyboardPanOffset: {
           type: Number,
           value: 80
      },
  
      /**
       * The `keyboard-zoom-offset` attribute sets the number of zoom levels to change when pressing + or - key.
       * 
       * @attribute keyboard-zoom-offset
       * @type number
       */
      keyboardZoomOffset: {
           type: Number,
           value: 1
      },
  
      /**
       * The `inertia` attribute sets whether panning of the map will have an inertia effect where the map builds momentum while dragging and continues moving in the same direction for some time. Feels especially nice on touch devices.
       * 
       * @attribute inertia
       * @type 
       */
      inertia: {
           type: Boolean,
           value: true
      },
  
      /**
       * The `inertia-deceleration` attribute sets the rate with which the inertial movement slows down, in pixels/second2.
       * 
       * @attribute inertia-deceleration
       * @type number
       */
      inertiaDeceleration: 3000,
  
      /**
       * The `inertia-max-speed` attribute sets the max speed of the inertial movement, in pixels/second.
       * 
       * @attribute inertia-max-speed
       * @type number
       */
      inertiaMaxSpeed: {
           type: Number,
           value: 1500
      },
  

      /**
       * The `box-zoom` attribute sets the whether the map can be zoomed to a rectangular area specified by dragging the mouse while pressing shift.
       * 
       * @attribute box-zoom
       * @type bool
       */
      boxZoom: {
           type: Boolean,
           value: true
      },

      /**
       * The `attribution-control` attribute sets whether the attribution control is added to the map by default.
       * 
       * @attribute attribution-control
       * @type bool
       */
      attributionControl: {
           type: Boolean,
           value: false
      },

      /**
       * The `zoom-animation-threshold` attribute sets the maximum number of zoom level differences that still use animation
       * 
       * @attribute zoom-animation-threshold
       * @type number
       */
      zoomAnimationThreshold: {
           type: Number,
           value: 4
      },
  
      /**
        * If set, the map is zoomed such that all elements in it are visible
        *
        * @attribute fit-to-markers
        * @type boolean
        * @default false
        */
      fitToMarkers: {
        type: Boolean,
        value: false
      },

      mapId: {
        type: String,
        value: 'mapbox.streets',
        notify: true
      },

      disableZoomUi: {
        type: Boolean,
        value: false
      },

      zoomable: {
        type: Boolean,
        value: true
      },

      geolocationUi: {
        type: Boolean,
        value: false,
        notify: true
      },
      
      fullscreenUi: {
        type: Boolean,
        value: false,
        notify: true
      },

      geocoderUi: {
        type: Boolean,
        value: false,
        notify: true
      },
      
      maxBounds: {
        type: Array,
        value: []
      },

      center: {
        type: Array,
        value: []
      }
    },
    map: undefined,



    // Methods


    ready: function(){
      var me = this;
      setTimeout(function() {me.domReady()}, 1);
    },

    domReady: function(){
      L.mapbox.accessToken = this.accessToken;
      var mapOptions = {
        tap: this.tap,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        boxZoom: this.boxZoom,
        inertia: this.inertia,
        dragging: this.dragging,
        keyboard: this.keyboard,
        touchZoom: this.zoomable,
        trackResize: this.trackResize,
        doubleClickZoom: this.zoomable,
        scrollWheelZoom: this.zoomable,
        tapTolerance: this.tapTolerance,
        zoomControl: !this.disableZoomUi,
        worldCopyJump: this.worldCopyJump,
        inertiaMaxSpeed: this.inertiaMaxSpeed,
        closePopupOnClick: this.closePopupOnClick,
        keyboardPanOffset: this.keyboardPanOffset,
        bounceAtZoomLimits: this.bounceAtZoomLimits,
        keyboardZoomOffset: this.keyboardZoomOffset,
        attributionControl: this.attributionControl,
        inertiaDeceleration: this.inertiaDeceleration,
        zoomAnimationThreshold: this.zoomAnimationThreshold
      };
      var map = L.mapbox.map( this.$.mapBox, this.mapId, mapOptions );
      this.map = map;
      this._updateCenter();

      map.on('click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu focus blur preclick load unload viewreset movestart move moveend dragstart drag dragend zoomstart zoomend zoomlevelschange resize autopanstart layeradd layerremove baselayerchange overlayadd overlayremove locationfound locationerror popupopen popupclose', function(e) {
        this.fire(e.type, e);
      }, this);

      map.on('moveend', function(e) {
        this._ignoreViewChange = true;
        this.longitude = map.getCenter().lng;
        this.latitude = map.getCenter().lat;
        this._ignoreViewChange = false;
      }, this);
      map.on('zoomend', function(e) {
        this.zoom = map.getZoom();
      }, this);


      // var defaultLayerRequired = true;
      // for (var i = 0; i < this.children.length; i++) {
      //   var e = this.children[i];
      //   if (e.isLayer && e.isLayer()) {
      //     defaultLayerRequired = false;
      //   }
      // }
      // if (defaultLayerRequired) {
      //   L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      //     attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery &copy; <a href="http://mapbox.com">Mapbox</a>',
      //     maxZoom: 18
      //   }).addTo(this.map);
      // }
      this.registerMapOnChildren();
      this._mutationObserver = new MutationObserver(this.registerMapOnChildren.bind(this));
      this._mutationObserver.observe(this, {childList: true});





      // this.map.on('zoomlevelschange', function (e) {
      //       this.fire( 'open-map-zoomened', {data: e});
      //   }.bind( this ) );

      // this.fire( 'open-map-ready' );

    },

    detached: function() {
      this._mutationObserver.disconnect();
    },

    registerMapOnChildren: function() {
      for (var i = 0; i < this.children.length; i++) {
        this.children[i].container = this.map;
      }
    },

    _updateCenter: function(){
      this.setCenter();
      if (this.map && !this._ignoreViewChange) {
        setTimeout(function() {
          this.map.setView(this.center, this.zoom);
        }.bind(this), 1);
      }
    },
    setCenter: function() {
        this.center = [];
        this.center[0] = this.latitude;
        this.center[1] = this.longitude;
    },

    updateMarkers: function() {
      this.layers = Array.prototype.slice.call(
        this.$.layers.getDistributedNodes()
      );

      // this.onMutation(this, this.updateMarkers);

      if (this.layers.length && this.map) {
        for (var i = 0, m; m = this.layers[i]; ++i) {
          m.map = this.map;
        }
      }
    },

    attached: function() {
      this.resize();
      // this.updateMarkers();
    },

    created:function(){
      this.layers = [];
    },

    disableZoomUiChanged: function( oldVal, newVal ){
      if( newVal ){
        this.map.zoomControl.removeFrom( this.map );
      }else{
        this.map.zoomControl.addTo( this.map );
      }
    },


    zoomChanged: function() {
      this.map.setZoom( Number( this.zoom ) );
      this.fire( 'open-map-zoomened', { data: this.zoom } );
    },

    toggleGeolocator: function () {
      var locate;
      if( this.geolocationUI ){
        locate = L.control.locate().addTo( this.map );
      }else if( locate ){
        locate.removeFrom( this.map );
      }
    },

    geolocationUIChanged: function() {
      this.toggleGeolocator();
    },

    toggleFullscreen: function () {
      var fullscreen;
      if( this.fullscreenUi ){
        fullscreen = L.control.fullscreen().addTo( this.map );
      }else if( fullscreen ){
        fullscreen.removeFrom( this.map );
      }
    },


    fullscreenUiChanged: function () {
      this.toggleFullscreen();
    },

    geocoderUiChanged: function () {
      this.toggleGeocoder();
    },

    resize: function () {
      if(this.map)
        this.map.on( 'resize', this._updateCenter.bind( this ) );
    },

    toggleGeocoder: function () {
        var geocoder;
        if( this.geocoderUi ){
          geocoder = this.map
            .addControl(L.mapbox.geocoderControl('mapbox.places-v1', {
              autocomplete: true
            }));
        }else if( geocoder ){
          this.map.removeControl( geocoder );
        }
      },

    maxBoundsChanged: function(oldVal, newVal){
      this.map.setMaxBounds(newVal);
      this.map.fitBounds(newVal);
    },

    

    /**
     * Delete the layers.
     *
     * @method clear
     */
    clear: function() {
      for( var i = 0, m; m = this.layers[i]; i++ ) {
        m.removeLayer();
        m.map = null;
      }
    }

  });
})();
</script>
